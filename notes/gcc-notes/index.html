<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Notes on GCC
        
    </title><meta content="Notes on GCC" property=og:title><link href=https://dipeshkaphle.github.io/fonts.css rel=stylesheet><script>MathJax={tex:{inlineMath:[[`\$`,`\$`],[`\\\\(`,`\\\\)`]]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://dipeshkaphle.github.io/atom.xml rel=alternate title=Dipesh type=application/atom+xml><link href=https://dipeshkaphle.github.io/theme/light.css rel=stylesheet><link href=https://dipeshkaphle.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://dipeshkaphle.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme())</script><link href=https://dipeshkaphle.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://dipeshkaphle.github.io>Dipesh</a><div class=socials><a class=social href=https://twitter.com/__dipesh_ rel=me> <img alt=twitter src=https://dipeshkaphle.github.io/social_icons/twitter.svg> </a><a class=social href=https://github.com/dipeshkaphle rel=me> <img alt=github src=https://dipeshkaphle.github.io/social_icons/github.svg> </a><a class=social href=https://linkedin.com/dipeshk111 rel=me> <img alt=linkedin src=https://dipeshkaphle.github.io/social_icons/linkedin.svg> </a></div></div><nav><a href=https://dipeshkaphle.github.io/about style=margin-left:.5em>/about</a><a href=https://dipeshkaphle.github.io/posts style=margin-left:.5em>/blog</a><a href=https://dipeshkaphle.github.io/notes style=margin-left:.5em>/notes</a><a href=https://dipeshkaphle.github.io/tags style=margin-left:.5em>/tags</a><a href=https://dipeshkaphle.github.io/projects style=margin-left:.5em>/projects</a><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://dipeshkaphle.github.io/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://dipeshkaphle.github.io/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Notes on GCC<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2023-02-24</time></div></div><section class=body><blockquote><p><strong>NOTE</strong> : This is still incomplete and I might add more content</blockquote><ul><li>Takes about 50 minutes for clean build on my current machine<li>X86-64 calling convention : <a href=https://en.wikipedia.org/wiki/X86_calling_conventions>Link</a><li><a href=https://gcc-newbies-guide.readthedocs.io/en/latest/inside-cc1.html>Inside CC1</a></ul><h2 id=setting-up-dev-environment>Setting Up Dev Environment</h2><ul><li><a href=https://gcc.gnu.org/wiki/Regenerating_GCC_Configuration#fnref-1ac2645085d52b5887d132f08d57c97f6969ef7d>Useful Link</a> (Important to learn if you want to hack on gcc)<li>Create a different build directory(convention followed). Build tree => build directory, Source tree => the root directory where source code lies.<li>Install bear to generate compile_commands.json</ul><pre style=color:#f8f8f2;background-color:#272822><code><span>$ ./contrib/download_prerequisites
</span><span>$ mkdir build # create build tree/directory
</span><span>$ cd build
</span><span>$ ../configure --prefix=$PWD/GCC-INSTALL-DIR --enable-languages=c,c++ --disable-bootstrap # Disable bootstrap to make build fast
</span><span>$ bear -- make -j$(nproc) # bear will generate compile_commands.json which will be used by development env for understanding about the repo
</span></code></pre><ul><li>See <a href=https://gcc-newbies-guide.readthedocs.io/en/latest/getting-started.html>this</a> to learn more about when to enable bootstrap and when to use multiple copies of the repo and things like that.<li>For cross compiling(this is just from my experience trying to compile for arm64 host and target, on my x86 machine)</ul><pre style=color:#f8f8f2;background-color:#272822><code><span>$ sudo pacman -S aarch64-linux-gnu-gcc \\ install cross compilers(this is for aarch64)
</span><span>$ mkdir build
</span><span>$ cd build
</span><span>$ ../configure --prefix=$PWD/GCC-12.2.0 --enable-languages=c,c++ --disable-bootstrap  --host=aarch64-linux-gnu --target=aarch64-linux-gnu
</span><span>$ clear; make -j$(nproc)
</span><span>$ make install
</span></code></pre><ul><li><a href=https://preshing.com/20141119/how-to-build-a-gcc-cross-compiler/>This</a> is more comprehensive guide for cross compiling.</ul><h3 id=tools-used-gcc-hacker-must-learn-properly>Tools used(Gcc hacker must learn properly)</h3><ul><li>Autoconf (<a href=https://en.wikipedia.org/wiki/Configure_script> configure.ac </a> files), Automake are used. <a href=https://en.wikipedia.org/wiki/Automake>Link(has a nice diagram about how they work together)</a><li>Configure shell scripts and .in header templates<li>Makefile is generated using Makefile.{def,tpl,in}(.in is generated from .def and .tpl using <code>autogen</code>) files present in source directory. This is done by the configure script and it should be generated in the build directory.<li>There are two level of configurations, the topmost <code>$GCCTOP/configure</code> and the one in <code>$GCCTOP/gcc/configure</code> (<code>GCCTOP => source directory</code>). Some configure arguments are passed from the topmost to the lower, but the topmost --help don't mention them.</ul><h3 id=must-understand>Must Understand</h3><ul><li>Source Directory and what they have . <a href=https://gcc.gnu.org/onlinedocs/gccint/Top-Level.html#Top-Level>Link</a><li>Gcc subdirectory. <a href=https://gcc.gnu.org/onlinedocs/gccint/gcc-Directory.html#gcc-Directory>Link</a><li>Passes</ul><h2 id=general-notes>General Notes</h2><blockquote><p>In general, the names of macros are all in uppercase, while the names of functions are entirely in lowercase. There are rare exceptions to this rule. You should assume that any macro or function whose name is made up entirely of uppercase letters may evaluate its arguments more than once. You may assume that a macro or function whose name is made up entirely of lowercase letters will evaluate its arguments only once.</blockquote><h2 id=lexing>Lexing</h2><p>First the input source is “tokenized”, so that the stream of input characters is divided into a stream of tokens. This is called “lexing”, and largely implemented in gcc in libcpp(folder in gcc) (which also implements the preprocessor - hence the name)<h2 id=parsing>Parsing</h2><blockquote><p><code>gcc -S &LTc-file> -O2 -fverbose-asm -fdump-tree-all -fdump-ipa-all -fdump-rtl-all</code> will generate dumps for every compiler pass that happened</blockquote><p>Next the frontend parses the tokens from a flat stream into a tree-like structure reflecting the grammar of the language (or complains about syntax errors or type errors, and bails out). This stage uses gcc’s <strong>tree</strong> type. There may be frontend-specific kinds of node, in the tree but the frontend will convert these to a generic form. <strong>Most warnings and lint things are implemented in this phase</strong>.<p>After each frontend the middle end “sees” a tree representation that we call <strong>generic</strong>. <strong>Generic</strong> IR closely resembles the original C code, but sometimes you will see control flow expressed via “goto” statements that go to numbered labels, and temporary variables introduced by the frontend.<h2 id=gimple>Gimple</h2><p>The tree-based IR can contain arbitrarily-complicated nested expressions, which is relatively easy for the frontends to generate, but difficult for the optimizer to work with, so GCC almost immediately converts it into a form named “gimple”. <a href=https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html>Gimple Documentation</a><h2 id=gimple-with-cfg-control-flow-graph>Gimple with CFG(Control Flow Graph)</h2><p><strong>Gimple</strong> is almost immediately converted to a CFG, a directed graph of "Basic Blocks"(Sequences of instructions with no control flow). The control flow is expressed as edges between the Basic Blocks.<blockquote><p><code>gcc -S &LTc-file> -O2 -fverbose-asm -fdump-tree-all-graph -fdump-ipa-all-graph -fdump-rtl-all-graph</code> will generate dot graph dumps for every compiler pass that happened,in addition to normal dumps generated without the graph suffix in the flags</blockquote><h2 id=gimple-ssa-static-single-assignment>Gimple SSA(Static Single Assignment)</h2><p>SSA form is commonly used inside compilers, as it makes many kinds of optimization much easier to implement. In SSA, every local variable is only ever assigned to once; if there are multiple assignments to a local variable, it gets split up into multiple versions. Pretty much any major compiler uses SSA form at one point. Heavily used in LLVM as well. More <a href=https://en.wikipedia.org/wiki/Static_single-assignment_form>here</a>. Involves concept such as 'phi-nodes' and more.<p>GCC-Gimple-SSA documentation: <a href=https://gcc.gnu.org/onlinedocs/gccint/Tree-SSA.html>here</a><p>In SSA form, almost 200 passes are there.<h3 id=intraprocedural-passes>Intraprocedural Passes</h3><p>These work on one function at a time. They have a “t” code in their dump file. For example, test.c.175t.switchlower is the dump file for an optimization pass which converts gimple switch statements into lower-level gimple statements and control flow (which doesn’t do anything in our example above, as it doesn’t have any switch statements; try writing a simple C source file with a switch statement and see what it does)<h3 id=interprocedural-passes>Interprocedural Passes</h3><p>Consider all of the functions at once, such as which functions call which other functions. These have an “i” code in their dump file.<blockquote><p>All sets of optimizations can be found in <code>gcc/passes.def</code>.</blockquote><h2 id=rtl>RTL</h2><ul><li>Gimple is converted to Register Transfer Language (RTL), a much lower-level representation of the code, which will allow us to eventually go all the way to assembler.<li>This conversion happens in an optimization pass called "expand".<li>RTL form of the IR is much closer to assembler: whereas gimple works in terms of variables of specific data types, RTL instructions work in terms of low-level operations on an arbitrary number of registers of specific bit sizes.</ul><h3 id=optimization-passes-in-rtl>Optimization passes in RTL</h3><ul><li><p>Implements calling convention of an ABI</p><li><p>Does register allocation</p><li><p>Uses actual instruction and addressing modes of CPU rather than assuming an ideal set of combinations</p><li><p>Optimizations such as scheduling instructions, handling delay slot, etc to make it run efficiently on the machine.</p><li><p>Converts the CFG that RTL inherited from gimple into a flat series of instructions connected by jumps (honoring constraints such as limitations on how many bytes a jump instruction can go)</p><li><p>Final form of RTL is generated in a pass called "final". This form is suitable for output in assembler.</p></ul><h2 id=generic>GENERIC</h2><ul><li>Union Crimes happening in codebase. Abusing union memory layout.. <code>tree_node</code> is a union, which has two fields that always need to exist. <code>TREE_CHAIN</code> and <code>TREE_TYPE</code> macros defined in <code>gcc/tree.h</code> need to access <code>common</code> and <code>typed</code> field of <code>tree_node</code>(in <code>gcc/tree-core.h</code>) and they'll always end up being valid because the minimum size of anything inside that union is <code>tree_typed</code>(which makes <code>TREE_TYPE</code> always valid because of union memory layout) and whenever they need to use <code>TREE_CHAIN</code>, many cases it's having <code>tree_common</code> as first field in struct and hence making it valid. I'm assuming this needs to be checked however as some type have <code>tree_typed</code> as member and not <code>tree_common</code> (maybe because they don't need the next pointer).</ul><h2 id=gimple-1>GIMPLE</h2><p><strong>INCOMPLETE</strong><h2 id=passes>Passes</h2><h3 id=frontend-passes>Frontend Passes</h3><ul><li>Language frontend is invoked only once.<li>I think gcc/toplev.cc is the driver program? I'm not sure<li>langs_hook.parse_file is invoked in <code>gcc/toplev.cc</code>. I'm not sure how this is working?<li>Each front end provides its own lang hook initializer. Lang hook routines common to C++ and ObjC++ appear in cp/cp-objcp-common.cc<li>Languages can use whatever intermediate language representation they want. (C uses GENERIC trees + some language specific tree codes, defined in c-common.def), while Fortran uses completely different private representation.<li>C Frontend invokes the gimplifier manually on each function and uses the callbacks to convert language specific tree nodes directly to <code>GIMPLE</code>, before passing the function off to be compiled. Fortran however follows private repr => GENERIC => GIMPLE path.<li>The call-graph is a data structure designed for inter-procedural optimization. It represents a multi-graph where nodes are functions (symbols within symbol table) and edges are call sites.<li>The front end needs to pass all function definitions and top level declarations off to the middle-end so that they can be compiled and emitted to the object file.</ul><h3 id=gimplification-passes>Gimplification Passes</h3><ul><li>Tree lowering pass. This pass converts the GENERIC functions-as-trees tree representation into the GIMPLE form.<li>The main entry point to this pass is <code>gimplify_function_tree</code> located in <code>gimplify.cc</code>. Processes entire function, gimplifying each of the statements. Main thing to look into is the <code>gimplify_expr</code>.<li>See <code>gcc/cgraphunit.cc</code> which implements main driver of the compilation process. This is where <code>lower_nested_functions</code> (in cgraphnode::analyze) is called which I inside it calls <code>gimplify_function_tree</code> inside it on all the functions. Also look into the <code>cgraph_node</code> structure defined in <code>gcc/cgraph.h</code>. (The call-graph is a data structure designed for inter-procedural optimization. It represents a multi-graph where nodes are functions (symbols within symbol table) and edges are call sites)<li>See <code>gimplify_stmt</code> and <code>gimplify_expr</code>(Has lots of comments to understand. TODO: understand this as I'm not clear with representation fully) in <code>gcc/gimplify.cc</code>.<li>There's a language specific <code>gimplify_expr</code> that will be implemented as language hook. Called in <code>gimplify_expr</code> in <code>gcc/gimplify.cc</code> as <code>lang_hooks.gimplify_expr</code></ul><h3 id=pass-manager>Pass Manager</h3><p><strong>INCOMPLETE</strong><h2 id=vectorization-related-things>Vectorization Related Things</h2><ul><li>Cost Model is described in <code>$(SOURCE_D)/gcc/tree-vect-loop.cc</code><li>More details <a href=http://gcc.gnu.org/projects/tree-ssa/vectorization.html>here</a></ul></section></article></main><hr><center><small>Copyright © Dipesh Kafle. All rights reserved. | Powered by <a href=https://getzola.org rel=nofollow>Zola</a> & <a href=https://github.com/not-matthias/apollo/ rel=nofollow>Apollo</a></small></center></div>
<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         What is a Fixed Point Combinator?
        
    </title><meta content="What is a Fixed Point Combinator?" property=og:title><link href=https://dipeshkaphle.github.io/fonts.css rel=stylesheet><script>MathJax={tex:{inlineMath:[[`\$`,`\$`],[`\\\\(`,`\\\\)`]]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://dipeshkaphle.github.io/atom.xml rel=alternate title=Dipesh type=application/atom+xml><link href=https://dipeshkaphle.github.io/theme/light.css rel=stylesheet><link href=https://dipeshkaphle.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://dipeshkaphle.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme())</script><link href=https://dipeshkaphle.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://dipeshkaphle.github.io>Dipesh</a><div class=socials><a class=social href=https://twitter.com/__dipesh_ rel=me> <img alt=twitter src=https://dipeshkaphle.github.io/social_icons/twitter.svg> </a><a class=social href=https://github.com/dipeshkaphle rel=me> <img alt=github src=https://dipeshkaphle.github.io/social_icons/github.svg> </a><a class=social href=https://linkedin.com/dipeshk111 rel=me> <img alt=linkedin src=https://dipeshkaphle.github.io/social_icons/linkedin.svg> </a></div></div><nav><a href=https://dipeshkaphle.github.io/about style=margin-left:.5em>/about</a><a href=https://dipeshkaphle.github.io/posts style=margin-left:.5em>/blog</a><a href=https://dipeshkaphle.github.io/notes style=margin-left:.5em>/notes</a><a href=https://dipeshkaphle.github.io/tags style=margin-left:.5em>/tags</a><a href=https://dipeshkaphle.github.io/projects style=margin-left:.5em>/projects</a><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://dipeshkaphle.github.io/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://dipeshkaphle.github.io/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>What is a Fixed Point Combinator?<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-03-28</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://dipeshkaphle.github.io/tags/pl/>PL</a> </span></div></div><section class=body><p>(Copy-pasting Wikipedia) A fixed-point combinator (or fixpoint combinator), is a higher-order function that returns some fixed point (a value that is mapped to itself) of its argument function, if one exists.<p>It has the following type(given in Haskell)<pre class=language-hs data-lang=hs style=color:#f8f8f2;background-color:#272822><code class=language-hs data-lang=hs><span style=color:#a6e22e>fix </span><span style=color:#f92672>::</span><span> (a </span><span style=color:#f92672>-> </span><span>a) </span><span style=color:#f92672>-> </span><span>a
</span></code></pre><p>We'll assume it's defined somewhere already and move on for now.<p>Now, a classic example for showing it's usage is a factorial function(or any recursive function would work).<p>Generally it would be written recursively like this:<pre class=language-hs data-lang=hs style=color:#f8f8f2;background-color:#272822><code class=language-hs data-lang=hs><span style=color:#a6e22e>fact</span><span style=color:#f92672>:: </span><span style=color:#66d9ef;font-style:italic>Integer </span><span style=color:#f92672>-> </span><span style=color:#66d9ef;font-style:italic>Integer
</span><span>fact n </span><span style=color:#f92672>= if</span><span> n </span><span style=color:#f92672>== </span><span style=color:#ae81ff>0 </span><span style=color:#f92672>then </span><span style=color:#ae81ff>1 </span><span style=color:#f92672>else</span><span> n * (fact (n </span><span style=color:#f92672>- </span><span style=color:#ae81ff>1</span><span>))
</span></code></pre><p>But, let's assume we don't have recursion in our language. So, let's try to write it a bit differently.<pre class=language-hs data-lang=hs style=color:#f8f8f2;background-color:#272822><code class=language-hs data-lang=hs><span style=color:#a6e22e>fact'</span><span style=color:#f92672>::</span><span> (</span><span style=color:#66d9ef;font-style:italic>Integer </span><span style=color:#f92672>-> </span><span style=color:#66d9ef;font-style:italic>Integer</span><span>) </span><span style=color:#f92672>-> </span><span style=color:#66d9ef;font-style:italic>Integer </span><span style=color:#f92672>-> </span><span style=color:#66d9ef;font-style:italic>Integer
</span><span>fact' f n </span><span style=color:#f92672>= if</span><span> n </span><span style=color:#f92672>== </span><span style=color:#ae81ff>0 </span><span style=color:#f92672>then </span><span style=color:#ae81ff>1 </span><span style=color:#f92672>else</span><span> n * (f (n </span><span style=color:#f92672>- </span><span style=color:#ae81ff>1</span><span>))
</span></code></pre><p>Now, using <code>fix</code>, we could define our <code>fact</code> to be something like this<pre class=language-hs data-lang=hs style=color:#f8f8f2;background-color:#272822><code class=language-hs data-lang=hs><span style=color:#75715e>-- fact:: Integer -> Integer
</span><span style=color:#75715e>-- fix:: (a -> a) -> a
</span><span style=color:#75715e>-- fact' :: (Integer -> Integer) -> Integer -> Integer
</span><span style=color:#75715e>-- which can be rewritten as
</span><span style=color:#75715e>-- fact' :: (Integer -> Integer) -> (Integer -> Integer)
</span><span style=color:#75715e>--
</span><span style=color:#75715e>-- in fix fact', a is substituted to be (Integer -> Integer)
</span><span style=color:#75715e>-- so fix fact:: Integer -> Integer
</span><span>fact n </span><span style=color:#f92672>=</span><span> fix fact'
</span></code></pre><p>But <code>fix</code> has been a blackbox for us till now. Let's see how we can define it.<pre style=color:#f8f8f2;background-color:#272822><code><span>fix:: (a -> a) -> a
</span><span>fix f = &LTt>
</span></code></pre><p>Now what could go in for <code>t</code> expression there? If we think purely in terms of types, we have a function as parameter <code>f: a-> a</code> and we need result to be of type <code>a</code>. So, it's probably going to be achieved by applying <code>f</code>.<p>Now, what is something of type <code>a</code> we can apply to <code>f: a -> a</code>. We really only know of one thing whose result is type <code>a</code> i.e <code>fix</code>. So, it's just going to be<pre style=color:#f8f8f2;background-color:#272822><code><span>fix f = f (fix f)
</span></code></pre><p>andd, that's the definition of <code>fix</code>, the fixed-point combinator.<blockquote><p>NOTE: Since, fix is defined recursively, it has to be a primitive provided by host language(language in which the interpreter is written), since we mentioned before we didn't support recursion.</blockquote><blockquote><p>NOTE: Also this definition of fix works in a call by name language(lazy language) like Haskell, but will overflow the stack in something like OCaml.</blockquote><h3 id=let-s-try-defining-it-in-ocaml>Let's try defining it in OCaml</h3><h4 id=why-do-we-need-to-do-it-differently-in-ocaml>Why do we need to do it differently in OCaml?</h4><p>Issue arises due to strictness. If you translate the program to OCaml, it'll be like this:<pre style=color:#f8f8f2;background-color:#272822><code><span>let rec fix f = f (fix f)
</span></code></pre><p>The issue with this is, the moment you call <code>fix</code> with some <code>f</code>, it'll first try to evaluate the <code>fix f</code> in RHS, which just keeps on going forever. Haskell doesn't suffer from the issue because it only actually evaluates it when it's needed.<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#272822><code class=language-bash data-lang=bash><span>ghci</span><span style=color:#f92672>></span><span> fix f = f (fix f)
</span><span>ghci</span><span style=color:#f92672>></span><span> x y = 1:y
</span><span>ghci</span><span style=color:#f92672>></span><span> infinite1s = fix x
</span><span>ghci</span><span style=color:#f92672>></span><span> take 10 infinite1s
</span><span>[1,1,1,1,1,1,1,1,1,1]
</span></code></pre><p>Using <code>fix</code>, we can define <code>x=1:x</code> like above. We basically took <code>x::[Integer] -> [Integer]</code> and converted it to <code>[Integer]</code> with <code>fix</code>.<p>You can't do this in OCaml directly. This is of the form <code>a -> a</code> where <code>a=[Integer]</code>. This form of fix with the signature <code>(a -> a) -> a</code> is possible in Haskell because <code>a</code> whatever it is, is lazily evaluated. It's actually a thunk which evaluates to <code>a</code>. In OCaml, <code>a</code> is always an evaluated value, so you will end up needing some thunking mechanism to define <code>fix</code>.<p>We need to get laziness to do this in OCaml. So, we'll use partially evaluated functions to get a definition of <code>fix</code>. We define it as follows:<pre class=language-ocaml data-lang=ocaml style=color:#f8f8f2;background-color:#272822><code class=language-ocaml data-lang=ocaml><span style=color:#f92672>val </span><span>fix : ((</span><span style=color:#66d9ef;font-style:italic>'a </span><span>-> </span><span style=color:#66d9ef;font-style:italic>'b</span><span>) -> </span><span style=color:#66d9ef;font-style:italic>'a </span><span>-> </span><span style=color:#66d9ef;font-style:italic>'b</span><span>) -> </span><span style=color:#66d9ef;font-style:italic>'a </span><span>-> </span><span style=color:#66d9ef;font-style:italic>'b
</span><span style=color:#f92672>let rec </span><span style=color:#a6e22e>fix </span><span style=color:#fd971f;font-style:italic>f x </span><span style=color:#f92672>= </span><span style=color:#66d9ef;font-style:italic>f </span><span>(</span><span style=color:#66d9ef;font-style:italic>fix f</span><span>) </span><span style=color:#66d9ef;font-style:italic>x
</span></code></pre><blockquote><p>(if you think about it, is sort of similar to <code>(a -> a)-> a</code> in Haskell, but <code>a</code> maps to <code>'a -> 'b</code> here.)</blockquote><p>This doesn't blow up because the usage of fix in RHS is also partial, it doesn't get fully evaluated until we actually use it. We end up creating lazy semantics of our own here.<pre class=language-bash data-lang=bash style=color:#f8f8f2;background-color:#272822><code class=language-bash data-lang=bash><span>utop </span><span style=color:#75715e># let rec fix f x = f (fix f) x;;
</span><span>val fix : ((</span><span style=color:#e6db74>'a -> '</span><span>b) -</span><span style=color:#f92672>> </span><span style=color:#e6db74>'a -> '</span><span>b) -</span><span style=color:#f92672>> </span><span style=color:#e6db74>'a -> '</span><span>b = </span><span style=color:#f92672><</span><span>fun</span><span style=color:#f92672>>
</span><span>─( 16:05:30 )─</span><span style=color:#f92672><</span><span> command 7 </span><span style=color:#f92672>></span><span>──────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
</span><span>utop </span><span style=color:#75715e># let fact f n = if n=0 then 1 else n * (f (n - 1));;
</span><span>val fact : (int -</span><span style=color:#f92672>></span><span> int) -</span><span style=color:#f92672>></span><span> int -</span><span style=color:#f92672>></span><span> int = </span><span style=color:#f92672><</span><span>fun</span><span style=color:#f92672>>
</span><span>─( 16:05:34 )─</span><span style=color:#f92672><</span><span> command 8 </span><span style=color:#f92672>></span><span>──────────────────────────────────────────────────────────────────────────────────────────────{ counter: 0 }─
</span><span>utop </span><span style=color:#75715e># (fix fact) 10;;
</span><span>- : int = 3628800
</span></code></pre><p>That's pretty much it.<blockquote><p>This sort of clicked properly for me when I was watching <a href="https://youtu.be/8cXl2Tfhy_Q?si=pQGGg_4bum-NQAhZ">this excellent lecture by Robert Harper</a>, so I thought I'd write it out as a small blog</blockquote></section></article></main><hr><center><small>Copyright © Dipesh Kafle. All rights reserved. | Powered by <a href=https://getzola.org rel=nofollow>Zola</a> & <a href=https://github.com/not-matthias/apollo/ rel=nofollow>Apollo</a></small></center></div>